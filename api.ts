/* tslint:disable */
/* eslint-disable */
/**
 * Swagger client library generator specs
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Benchmark
 */
export interface Benchmark {
    /**
     * String with a docker hub container name
     * @type {string}
     * @memberof Benchmark
     */
    'docker_image': string;
    /**
     * String with a docker hub container tag
     * @type {string}
     * @memberof Benchmark
     */
    'docker_tag': string;
    /**
     * 
     * @type {object}
     * @memberof Benchmark
     */
    'json_schema': object;
    /**
     * String with an statement about the object
     * @type {string}
     * @memberof Benchmark
     */
    'description'?: string;
    /**
     * Upload datetime of the referred resource
     * @type {string}
     * @memberof Benchmark
     */
    'upload_datetime': string;
    /**
     * UUID resource unique identification
     * @type {string}
     * @memberof Benchmark
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Benchmarks
 */
export interface Benchmarks {
    /**
     * True if a next page exists
     * @type {boolean}
     * @memberof Benchmarks
     */
    'has_next': boolean;
    /**
     * True if a previous page exists
     * @type {boolean}
     * @memberof Benchmarks
     */
    'has_prev': boolean;
    /**
     * Number of the next page
     * @type {number}
     * @memberof Benchmarks
     */
    'next_num': number;
    /**
     * Number of the previous page
     * @type {number}
     * @memberof Benchmarks
     */
    'prev_num': number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof Benchmarks
     */
    'pages': number;
    /**
     * The number of items to be displayed on a page
     * @type {number}
     * @memberof Benchmarks
     */
    'per_page': number;
    /**
     * The return page number (1 indexed)
     * @type {number}
     * @memberof Benchmarks
     */
    'page': number;
    /**
     * The total number of items matching the query
     * @type {number}
     * @memberof Benchmarks
     */
    'total': number;
    /**
     * 
     * @type {Array<Benchmark>}
     * @memberof Benchmarks
     */
    'items': Array<Benchmark>;
}
/**
 * 
 * @export
 * @interface Claim
 */
export interface Claim {
    /**
     * Resource type discriminator
     * @type {string}
     * @memberof Claim
     */
    'message': string;
    /**
     * Upload datetime of the referred resource
     * @type {string}
     * @memberof Claim
     */
    'upload_datetime': string;
    /**
     * UUID resource unique identification
     * @type {string}
     * @memberof Claim
     */
    'id': string;
    /**
     * Resource type discriminator
     * @type {string}
     * @memberof Claim
     */
    'resource_type': ClaimResourceTypeEnum;
    /**
     * UUID resource unique identification
     * @type {string}
     * @memberof Claim
     */
    'resource_id': string;
    /**
     * 
     * @type {SubmitUploader}
     * @memberof Claim
     */
    'uploader': SubmitUploader;
}

export const ClaimResourceTypeEnum = {
    Result: 'result'
} as const;

export type ClaimResourceTypeEnum = typeof ClaimResourceTypeEnum[keyof typeof ClaimResourceTypeEnum];

/**
 * 
 * @export
 * @interface Claims
 */
export interface Claims {
    /**
     * True if a next page exists
     * @type {boolean}
     * @memberof Claims
     */
    'has_next': boolean;
    /**
     * True if a previous page exists
     * @type {boolean}
     * @memberof Claims
     */
    'has_prev': boolean;
    /**
     * Number of the next page
     * @type {number}
     * @memberof Claims
     */
    'next_num': number;
    /**
     * Number of the previous page
     * @type {number}
     * @memberof Claims
     */
    'prev_num': number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof Claims
     */
    'pages': number;
    /**
     * The number of items to be displayed on a page
     * @type {number}
     * @memberof Claims
     */
    'per_page': number;
    /**
     * The return page number (1 indexed)
     * @type {number}
     * @memberof Claims
     */
    'page': number;
    /**
     * The total number of items matching the query
     * @type {number}
     * @memberof Claims
     */
    'total': number;
    /**
     * 
     * @type {Array<Claim>}
     * @memberof Claims
     */
    'items': Array<Claim>;
}
/**
 * 
 * @export
 * @interface CreateBenchmark
 */
export interface CreateBenchmark {
    /**
     * String with a docker hub container name
     * @type {string}
     * @memberof CreateBenchmark
     */
    'docker_image': string;
    /**
     * String with a docker hub container tag
     * @type {string}
     * @memberof CreateBenchmark
     */
    'docker_tag': string;
    /**
     * 
     * @type {object}
     * @memberof CreateBenchmark
     */
    'json_schema': object;
    /**
     * String with an statement about the object
     * @type {string}
     * @memberof CreateBenchmark
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateClaim
 */
export interface CreateClaim {
    /**
     * Resource type discriminator
     * @type {string}
     * @memberof CreateClaim
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CreateFlavor
 */
export interface CreateFlavor {
    /**
     * String with virtual hardware template identification
     * @type {string}
     * @memberof CreateFlavor
     */
    'name': string;
    /**
     * String with an statement about the object
     * @type {string}
     * @memberof CreateFlavor
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateSite
 */
export interface CreateSite {
    /**
     * String with human readable institution identification
     * @type {string}
     * @memberof CreateSite
     */
    'name': string;
    /**
     * String with place where a site is located
     * @type {string}
     * @memberof CreateSite
     */
    'address': string;
    /**
     * String with an statement about the object
     * @type {string}
     * @memberof CreateSite
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateTag
 */
export interface CreateTag {
    /**
     * String with short feature identification
     * @type {string}
     * @memberof CreateTag
     */
    'name': string;
    /**
     * String with an statement about the object
     * @type {string}
     * @memberof CreateTag
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Flavor
 */
export interface Flavor {
    /**
     * String with virtual hardware template identification
     * @type {string}
     * @memberof Flavor
     */
    'name': string;
    /**
     * String with an statement about the object
     * @type {string}
     * @memberof Flavor
     */
    'description'?: string;
    /**
     * Upload datetime of the referred resource
     * @type {string}
     * @memberof Flavor
     */
    'upload_datetime': string;
    /**
     * UUID resource unique identification
     * @type {string}
     * @memberof Flavor
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Flavors
 */
export interface Flavors {
    /**
     * True if a next page exists
     * @type {boolean}
     * @memberof Flavors
     */
    'has_next': boolean;
    /**
     * True if a previous page exists
     * @type {boolean}
     * @memberof Flavors
     */
    'has_prev': boolean;
    /**
     * Number of the next page
     * @type {number}
     * @memberof Flavors
     */
    'next_num': number;
    /**
     * Number of the previous page
     * @type {number}
     * @memberof Flavors
     */
    'prev_num': number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof Flavors
     */
    'pages': number;
    /**
     * The number of items to be displayed on a page
     * @type {number}
     * @memberof Flavors
     */
    'per_page': number;
    /**
     * The return page number (1 indexed)
     * @type {number}
     * @memberof Flavors
     */
    'page': number;
    /**
     * The total number of items matching the query
     * @type {number}
     * @memberof Flavors
     */
    'total': number;
    /**
     * 
     * @type {Array<Flavor>}
     * @memberof Flavors
     */
    'items': Array<Flavor>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
    /**
     * Errors
     * @type {object}
     * @memberof ModelError
     */
    'errors'?: object;
    /**
     * Error name
     * @type {string}
     * @memberof ModelError
     */
    'status'?: string;
    /**
     * Error code
     * @type {number}
     * @memberof ModelError
     */
    'code'?: number;
}
/**
 * 
 * @export
 * @interface PaginationMetadata
 */
export interface PaginationMetadata {
    /**
     * 
     * @type {number}
     * @memberof PaginationMetadata
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetadata
     */
    'total_pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetadata
     */
    'first_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetadata
     */
    'last_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetadata
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetadata
     */
    'previous_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetadata
     */
    'next_page'?: number;
}
/**
 * 
 * @export
 * @interface Result
 */
export interface Result {
    /**
     * Upload datetime of the referred resource
     * @type {string}
     * @memberof Result
     */
    'upload_datetime': string;
    /**
     * UUID resource unique identification
     * @type {string}
     * @memberof Result
     */
    'id': string;
    /**
     * START execution datetime of the result
     * @type {string}
     * @memberof Result
     */
    'execution_datetime': string;
    /**
     * 
     * @type {Benchmark}
     * @memberof Result
     */
    'benchmark': Benchmark;
    /**
     * 
     * @type {Site}
     * @memberof Result
     */
    'site': Site;
    /**
     * 
     * @type {Flavor}
     * @memberof Result
     */
    'flavor': Flavor;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Result
     */
    'tags': Array<Tag>;
    /**
     * 
     * @type {object}
     * @memberof Result
     */
    'json': object;
}
/**
 * 
 * @export
 * @interface Results
 */
export interface Results {
    /**
     * True if a next page exists
     * @type {boolean}
     * @memberof Results
     */
    'has_next': boolean;
    /**
     * True if a previous page exists
     * @type {boolean}
     * @memberof Results
     */
    'has_prev': boolean;
    /**
     * Number of the next page
     * @type {number}
     * @memberof Results
     */
    'next_num': number;
    /**
     * Number of the previous page
     * @type {number}
     * @memberof Results
     */
    'prev_num': number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof Results
     */
    'pages': number;
    /**
     * The number of items to be displayed on a page
     * @type {number}
     * @memberof Results
     */
    'per_page': number;
    /**
     * The return page number (1 indexed)
     * @type {number}
     * @memberof Results
     */
    'page': number;
    /**
     * The total number of items matching the query
     * @type {number}
     * @memberof Results
     */
    'total': number;
    /**
     * 
     * @type {Array<Result>}
     * @memberof Results
     */
    'items': Array<Result>;
}
/**
 * 
 * @export
 * @interface Site
 */
export interface Site {
    /**
     * String with human readable institution identification
     * @type {string}
     * @memberof Site
     */
    'name': string;
    /**
     * String with place where a site is located
     * @type {string}
     * @memberof Site
     */
    'address': string;
    /**
     * String with an statement about the object
     * @type {string}
     * @memberof Site
     */
    'description'?: string;
    /**
     * Upload datetime of the referred resource
     * @type {string}
     * @memberof Site
     */
    'upload_datetime': string;
    /**
     * UUID resource unique identification
     * @type {string}
     * @memberof Site
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Sites
 */
export interface Sites {
    /**
     * True if a next page exists
     * @type {boolean}
     * @memberof Sites
     */
    'has_next': boolean;
    /**
     * True if a previous page exists
     * @type {boolean}
     * @memberof Sites
     */
    'has_prev': boolean;
    /**
     * Number of the next page
     * @type {number}
     * @memberof Sites
     */
    'next_num': number;
    /**
     * Number of the previous page
     * @type {number}
     * @memberof Sites
     */
    'prev_num': number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof Sites
     */
    'pages': number;
    /**
     * The number of items to be displayed on a page
     * @type {number}
     * @memberof Sites
     */
    'per_page': number;
    /**
     * The return page number (1 indexed)
     * @type {number}
     * @memberof Sites
     */
    'page': number;
    /**
     * The total number of items matching the query
     * @type {number}
     * @memberof Sites
     */
    'total': number;
    /**
     * 
     * @type {Array<Site>}
     * @memberof Sites
     */
    'items': Array<Site>;
}
/**
 * 
 * @export
 * @interface Submit
 */
export interface Submit {
    /**
     * Upload datetime of the referred resource
     * @type {string}
     * @memberof Submit
     */
    'upload_datetime': string;
    /**
     * Resource type discriminator
     * @type {string}
     * @memberof Submit
     */
    'resource_type': SubmitResourceTypeEnum;
    /**
     * UUID resource unique identification
     * @type {string}
     * @memberof Submit
     */
    'resource_id': string;
    /**
     * 
     * @type {SubmitUploader}
     * @memberof Submit
     */
    'uploader': SubmitUploader;
}

export const SubmitResourceTypeEnum = {
    Benchmark: 'benchmark',
    Claim: 'claim',
    Site: 'site',
    Flavor: 'flavor'
} as const;

export type SubmitResourceTypeEnum = typeof SubmitResourceTypeEnum[keyof typeof SubmitResourceTypeEnum];

/**
 * 
 * @export
 * @interface SubmitUploader
 */
export interface SubmitUploader {
    /**
     * String containing an OIDC subject
     * @type {string}
     * @memberof SubmitUploader
     */
    'sub': string;
    /**
     * String containing an OIDC issuer
     * @type {string}
     * @memberof SubmitUploader
     */
    'iss': string;
    /**
     * Email of user collected by the OIDC token
     * @type {string}
     * @memberof SubmitUploader
     */
    'email': string;
    /**
     * Time when the user was registered
     * @type {string}
     * @memberof SubmitUploader
     */
    'registration_datetime': string;
}
/**
 * 
 * @export
 * @interface Submits
 */
export interface Submits {
    /**
     * True if a next page exists
     * @type {boolean}
     * @memberof Submits
     */
    'has_next': boolean;
    /**
     * True if a previous page exists
     * @type {boolean}
     * @memberof Submits
     */
    'has_prev': boolean;
    /**
     * Number of the next page
     * @type {number}
     * @memberof Submits
     */
    'next_num': number;
    /**
     * Number of the previous page
     * @type {number}
     * @memberof Submits
     */
    'prev_num': number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof Submits
     */
    'pages': number;
    /**
     * The number of items to be displayed on a page
     * @type {number}
     * @memberof Submits
     */
    'per_page': number;
    /**
     * The return page number (1 indexed)
     * @type {number}
     * @memberof Submits
     */
    'page': number;
    /**
     * The total number of items matching the query
     * @type {number}
     * @memberof Submits
     */
    'total': number;
    /**
     * 
     * @type {Array<Submit>}
     * @memberof Submits
     */
    'items': Array<Submit>;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * String with short feature identification
     * @type {string}
     * @memberof Tag
     */
    'name': string;
    /**
     * String with an statement about the object
     * @type {string}
     * @memberof Tag
     */
    'description'?: string;
    /**
     * UUID resource unique identification
     * @type {string}
     * @memberof Tag
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Tags
 */
export interface Tags {
    /**
     * True if a next page exists
     * @type {boolean}
     * @memberof Tags
     */
    'has_next': boolean;
    /**
     * True if a previous page exists
     * @type {boolean}
     * @memberof Tags
     */
    'has_prev': boolean;
    /**
     * Number of the next page
     * @type {number}
     * @memberof Tags
     */
    'next_num': number;
    /**
     * Number of the previous page
     * @type {number}
     * @memberof Tags
     */
    'prev_num': number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof Tags
     */
    'pages': number;
    /**
     * The number of items to be displayed on a page
     * @type {number}
     * @memberof Tags
     */
    'per_page': number;
    /**
     * The return page number (1 indexed)
     * @type {number}
     * @memberof Tags
     */
    'page': number;
    /**
     * The total number of items matching the query
     * @type {number}
     * @memberof Tags
     */
    'total': number;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Tags
     */
    'items': Array<Tag>;
}
/**
 * 
 * @export
 * @interface TagsIds
 */
export interface TagsIds {
    /**
     * 
     * @type {Array<string>}
     * @memberof TagsIds
     */
    'tags_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * String containing an OIDC subject
     * @type {string}
     * @memberof User
     */
    'sub': string;
    /**
     * String containing an OIDC issuer
     * @type {string}
     * @memberof User
     */
    'iss': string;
    /**
     * Email of user collected by the OIDC token
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * Time when the user was registered
     * @type {string}
     * @memberof User
     */
    'registration_datetime': string;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * True if a next page exists
     * @type {boolean}
     * @memberof Users
     */
    'has_next': boolean;
    /**
     * True if a previous page exists
     * @type {boolean}
     * @memberof Users
     */
    'has_prev': boolean;
    /**
     * Number of the next page
     * @type {number}
     * @memberof Users
     */
    'next_num': number;
    /**
     * Number of the previous page
     * @type {number}
     * @memberof Users
     */
    'prev_num': number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof Users
     */
    'pages': number;
    /**
     * The number of items to be displayed on a page
     * @type {number}
     * @memberof Users
     */
    'per_page': number;
    /**
     * The return page number (1 indexed)
     * @type {number}
     * @memberof Users
     */
    'page': number;
    /**
     * The total number of items matching the query
     * @type {number}
     * @memberof Users
     */
    'total': number;
    /**
     * 
     * @type {Array<User>}
     * @memberof Users
     */
    'items': Array<User>;
}

/**
 * BenchmarksApi - axios parameter creator
 * @export
 */
export const BenchmarksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this method to approve an specific benchmark submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Approves a benchmark to include it on default list methods
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveBenchmark: async (benchmarkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'benchmarkId' is not null or undefined
            assertParamExists('approveBenchmark', 'benchmarkId', benchmarkId)
            const localVarPath = `/benchmarks/{benchmark_id}:approve`
                .replace(`{${"benchmark_id"}}`, encodeURIComponent(String(benchmarkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to create a new benchmarks in the database so it can be accessed by the application users. The method returns the complete created benchmark (if succeeds).  Note: Benchmark use JSON Schemas to implement results validation.
         * @summary (Users) Uploads a new benchmark
         * @param {CreateBenchmark} createBenchmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBenchmark: async (createBenchmark: CreateBenchmark, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBenchmark' is not null or undefined
            assertParamExists('createBenchmark', 'createBenchmark', createBenchmark)
            const localVarPath = `/benchmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBenchmark, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to delete a specific benchmark from the database.
         * @summary (Admins) Deletes an existing benchmark
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBenchmark: async (benchmarkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'benchmarkId' is not null or undefined
            assertParamExists('deleteBenchmark', 'benchmarkId', benchmarkId)
            const localVarPath = `/benchmarks/{benchmark_id}`
                .replace(`{${"benchmark_id"}}`, encodeURIComponent(String(benchmarkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve a specific benchmark from the database.
         * @summary (Public) Retrieves benchmark details
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenchmark: async (benchmarkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'benchmarkId' is not null or undefined
            assertParamExists('getBenchmark', 'benchmarkId', benchmarkId)
            const localVarPath = `/benchmarks/{benchmark_id}`
                .replace(`{${"benchmark_id"}}`, encodeURIComponent(String(benchmarkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of benchmarks filtered according to your requirements. The response returns a pagination object with the filtered benchmarks (if succeeds).
         * @summary (Public) Filters and list benchmarks
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [dockerImage] String with a docker hub container name
         * @param {string} [dockerTag] String with a docker hub container tag
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [docker_image,docker_tag]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBenchmarks: async (status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, dockerImage?: string, dockerTag?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benchmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (dockerImage !== undefined) {
                localVarQueryParameter['docker_image'] = dockerImage;
            }

            if (dockerTag !== undefined) {
                localVarQueryParameter['docker_tag'] = dockerTag;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method instead of DELETE as it raises 422 in case the resource was already approved. Use this method to reject an specific benchmark submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Rejects a benchmark to safe delete it.
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectBenchmark: async (benchmarkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'benchmarkId' is not null or undefined
            assertParamExists('rejectBenchmark', 'benchmarkId', benchmarkId)
            const localVarPath = `/benchmarks/{benchmark_id}:reject`
                .replace(`{${"benchmark_id"}}`, encodeURIComponent(String(benchmarkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of benchmarks based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all benchmarks with \'v1\' and \'0\' on the \'docker_image\', \'docker_tag\' or \'description\' fields. The response returns a pagination object with the filtered benchmarks (if succeeds).
         * @summary (Public) Filters and list benchmarks
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBenchmarks: async (terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benchmarks:search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (terms) {
                localVarQueryParameter['terms'] = terms;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to update a specific benchmark from the database.
         * @summary (Admins) Implements JSON Put for benchmarks
         * @param {string} benchmarkId 
         * @param {Benchmark} benchmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBenchmark: async (benchmarkId: string, benchmark: Benchmark, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'benchmarkId' is not null or undefined
            assertParamExists('updateBenchmark', 'benchmarkId', benchmarkId)
            // verify required parameter 'benchmark' is not null or undefined
            assertParamExists('updateBenchmark', 'benchmark', benchmark)
            const localVarPath = `/benchmarks/{benchmark_id}`
                .replace(`{${"benchmark_id"}}`, encodeURIComponent(String(benchmarkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(benchmark, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BenchmarksApi - functional programming interface
 * @export
 */
export const BenchmarksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BenchmarksApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this method to approve an specific benchmark submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Approves a benchmark to include it on default list methods
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveBenchmark(benchmarkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveBenchmark(benchmarkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to create a new benchmarks in the database so it can be accessed by the application users. The method returns the complete created benchmark (if succeeds).  Note: Benchmark use JSON Schemas to implement results validation.
         * @summary (Users) Uploads a new benchmark
         * @param {CreateBenchmark} createBenchmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBenchmark(createBenchmark: CreateBenchmark, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Benchmark>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBenchmark(createBenchmark, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to delete a specific benchmark from the database.
         * @summary (Admins) Deletes an existing benchmark
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBenchmark(benchmarkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBenchmark(benchmarkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve a specific benchmark from the database.
         * @summary (Public) Retrieves benchmark details
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenchmark(benchmarkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Benchmark>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenchmark(benchmarkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of benchmarks filtered according to your requirements. The response returns a pagination object with the filtered benchmarks (if succeeds).
         * @summary (Public) Filters and list benchmarks
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [dockerImage] String with a docker hub container name
         * @param {string} [dockerTag] String with a docker hub container tag
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [docker_image,docker_tag]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBenchmarks(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, dockerImage?: string, dockerTag?: string, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Benchmarks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBenchmarks(status, uploadBefore, uploadAfter, perPage, page, dockerImage, dockerTag, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method instead of DELETE as it raises 422 in case the resource was already approved. Use this method to reject an specific benchmark submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Rejects a benchmark to safe delete it.
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectBenchmark(benchmarkId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectBenchmark(benchmarkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of benchmarks based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all benchmarks with \'v1\' and \'0\' on the \'docker_image\', \'docker_tag\' or \'description\' fields. The response returns a pagination object with the filtered benchmarks (if succeeds).
         * @summary (Public) Filters and list benchmarks
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBenchmarks(terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Benchmarks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchBenchmarks(terms, sortBy, status, uploadBefore, uploadAfter, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to update a specific benchmark from the database.
         * @summary (Admins) Implements JSON Put for benchmarks
         * @param {string} benchmarkId 
         * @param {Benchmark} benchmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBenchmark(benchmarkId: string, benchmark: Benchmark, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBenchmark(benchmarkId, benchmark, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BenchmarksApi - factory interface
 * @export
 */
export const BenchmarksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BenchmarksApiFp(configuration)
    return {
        /**
         * Use this method to approve an specific benchmark submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Approves a benchmark to include it on default list methods
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveBenchmark(benchmarkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.approveBenchmark(benchmarkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to create a new benchmarks in the database so it can be accessed by the application users. The method returns the complete created benchmark (if succeeds).  Note: Benchmark use JSON Schemas to implement results validation.
         * @summary (Users) Uploads a new benchmark
         * @param {CreateBenchmark} createBenchmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBenchmark(createBenchmark: CreateBenchmark, options?: any): AxiosPromise<Benchmark> {
            return localVarFp.createBenchmark(createBenchmark, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to delete a specific benchmark from the database.
         * @summary (Admins) Deletes an existing benchmark
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBenchmark(benchmarkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBenchmark(benchmarkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve a specific benchmark from the database.
         * @summary (Public) Retrieves benchmark details
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenchmark(benchmarkId: string, options?: any): AxiosPromise<Benchmark> {
            return localVarFp.getBenchmark(benchmarkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of benchmarks filtered according to your requirements. The response returns a pagination object with the filtered benchmarks (if succeeds).
         * @summary (Public) Filters and list benchmarks
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [dockerImage] String with a docker hub container name
         * @param {string} [dockerTag] String with a docker hub container tag
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [docker_image,docker_tag]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBenchmarks(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, dockerImage?: string, dockerTag?: string, sortBy?: string, options?: any): AxiosPromise<Benchmarks> {
            return localVarFp.listBenchmarks(status, uploadBefore, uploadAfter, perPage, page, dockerImage, dockerTag, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method instead of DELETE as it raises 422 in case the resource was already approved. Use this method to reject an specific benchmark submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Rejects a benchmark to safe delete it.
         * @param {string} benchmarkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectBenchmark(benchmarkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rejectBenchmark(benchmarkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of benchmarks based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all benchmarks with \'v1\' and \'0\' on the \'docker_image\', \'docker_tag\' or \'description\' fields. The response returns a pagination object with the filtered benchmarks (if succeeds).
         * @summary (Public) Filters and list benchmarks
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBenchmarks(terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: any): AxiosPromise<Benchmarks> {
            return localVarFp.searchBenchmarks(terms, sortBy, status, uploadBefore, uploadAfter, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to update a specific benchmark from the database.
         * @summary (Admins) Implements JSON Put for benchmarks
         * @param {string} benchmarkId 
         * @param {Benchmark} benchmark 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBenchmark(benchmarkId: string, benchmark: Benchmark, options?: any): AxiosPromise<void> {
            return localVarFp.updateBenchmark(benchmarkId, benchmark, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BenchmarksApi - object-oriented interface
 * @export
 * @class BenchmarksApi
 * @extends {BaseAPI}
 */
export class BenchmarksApi extends BaseAPI {
    /**
     * Use this method to approve an specific benchmark submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
     * @summary (Admins) Approves a benchmark to include it on default list methods
     * @param {string} benchmarkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BenchmarksApi
     */
    public approveBenchmark(benchmarkId: string, options?: AxiosRequestConfig) {
        return BenchmarksApiFp(this.configuration).approveBenchmark(benchmarkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to create a new benchmarks in the database so it can be accessed by the application users. The method returns the complete created benchmark (if succeeds).  Note: Benchmark use JSON Schemas to implement results validation.
     * @summary (Users) Uploads a new benchmark
     * @param {CreateBenchmark} createBenchmark 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BenchmarksApi
     */
    public createBenchmark(createBenchmark: CreateBenchmark, options?: AxiosRequestConfig) {
        return BenchmarksApiFp(this.configuration).createBenchmark(createBenchmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to delete a specific benchmark from the database.
     * @summary (Admins) Deletes an existing benchmark
     * @param {string} benchmarkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BenchmarksApi
     */
    public deleteBenchmark(benchmarkId: string, options?: AxiosRequestConfig) {
        return BenchmarksApiFp(this.configuration).deleteBenchmark(benchmarkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve a specific benchmark from the database.
     * @summary (Public) Retrieves benchmark details
     * @param {string} benchmarkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BenchmarksApi
     */
    public getBenchmark(benchmarkId: string, options?: AxiosRequestConfig) {
        return BenchmarksApiFp(this.configuration).getBenchmark(benchmarkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of benchmarks filtered according to your requirements. The response returns a pagination object with the filtered benchmarks (if succeeds).
     * @summary (Public) Filters and list benchmarks
     * @param {'on_review' | 'approved'} [status] Resource current state
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {string} [dockerImage] String with a docker hub container name
     * @param {string} [dockerTag] String with a docker hub container tag
     * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [docker_image,docker_tag]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BenchmarksApi
     */
    public listBenchmarks(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, dockerImage?: string, dockerTag?: string, sortBy?: string, options?: AxiosRequestConfig) {
        return BenchmarksApiFp(this.configuration).listBenchmarks(status, uploadBefore, uploadAfter, perPage, page, dockerImage, dockerTag, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method instead of DELETE as it raises 422 in case the resource was already approved. Use this method to reject an specific benchmark submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
     * @summary (Admins) Rejects a benchmark to safe delete it.
     * @param {string} benchmarkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BenchmarksApi
     */
    public rejectBenchmark(benchmarkId: string, options?: AxiosRequestConfig) {
        return BenchmarksApiFp(this.configuration).rejectBenchmark(benchmarkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of benchmarks based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all benchmarks with \'v1\' and \'0\' on the \'docker_image\', \'docker_tag\' or \'description\' fields. The response returns a pagination object with the filtered benchmarks (if succeeds).
     * @summary (Public) Filters and list benchmarks
     * @param {Array<string>} [terms] List of terms (string subsets)
     * @param {string} [sortBy] Order to return the results (coma separated)
     * @param {'on_review' | 'approved'} [status] Resource current state
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BenchmarksApi
     */
    public searchBenchmarks(terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: AxiosRequestConfig) {
        return BenchmarksApiFp(this.configuration).searchBenchmarks(terms, sortBy, status, uploadBefore, uploadAfter, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to update a specific benchmark from the database.
     * @summary (Admins) Implements JSON Put for benchmarks
     * @param {string} benchmarkId 
     * @param {Benchmark} benchmark 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BenchmarksApi
     */
    public updateBenchmark(benchmarkId: string, benchmark: Benchmark, options?: AxiosRequestConfig) {
        return BenchmarksApiFp(this.configuration).updateBenchmark(benchmarkId, benchmark, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FlavorsApi - axios parameter creator
 * @export
 */
export const FlavorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this method to approve an specific flavor submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Approves a flavor to include it on default list methods
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveFlavor: async (flavorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('approveFlavor', 'flavorId', flavorId)
            const localVarPath = `/flavors/{flavor_id}:approve`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to delete a specific flavor from the database.
         * @summary (Admins) Deletes an existing flavor
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlavor: async (flavorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('deleteFlavor', 'flavorId', flavorId)
            const localVarPath = `/flavors/{flavor_id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve a specific flavor from the database.
         * @summary (Public) Retrieves flavor details
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlavor: async (flavorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('getFlavor', 'flavorId', flavorId)
            const localVarPath = `/flavors/{flavor_id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve the site information from a specific flavor in the database.
         * @summary (Public) Retrieves flavor site details
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlavorSite: async (flavorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('getFlavorSite', 'flavorId', flavorId)
            const localVarPath = `/flavors/{flavor_id}/site`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method instead of DELETE as it raises 422 in case the resource was already approved.  Use this method to reject an specific flavor submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Rejects a flavor to safe delete it.
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFlavor: async (flavorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('rejectFlavor', 'flavorId', flavorId)
            const localVarPath = `/flavors/{flavor_id}:reject`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to update a specific flavor from the database.
         * @summary (Admins) Updates an existing flavor
         * @param {string} flavorId 
         * @param {Flavor} flavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlavor: async (flavorId: string, flavor: Flavor, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('updateFlavor', 'flavorId', flavorId)
            // verify required parameter 'flavor' is not null or undefined
            assertParamExists('updateFlavor', 'flavor', flavor)
            const localVarPath = `/flavors/{flavor_id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlavorsApi - functional programming interface
 * @export
 */
export const FlavorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlavorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this method to approve an specific flavor submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Approves a flavor to include it on default list methods
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveFlavor(flavorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveFlavor(flavorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to delete a specific flavor from the database.
         * @summary (Admins) Deletes an existing flavor
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlavor(flavorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlavor(flavorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve a specific flavor from the database.
         * @summary (Public) Retrieves flavor details
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlavor(flavorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlavor(flavorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve the site information from a specific flavor in the database.
         * @summary (Public) Retrieves flavor site details
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlavorSite(flavorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlavorSite(flavorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method instead of DELETE as it raises 422 in case the resource was already approved.  Use this method to reject an specific flavor submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Rejects a flavor to safe delete it.
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectFlavor(flavorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectFlavor(flavorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to update a specific flavor from the database.
         * @summary (Admins) Updates an existing flavor
         * @param {string} flavorId 
         * @param {Flavor} flavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFlavor(flavorId: string, flavor: Flavor, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFlavor(flavorId, flavor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FlavorsApi - factory interface
 * @export
 */
export const FlavorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlavorsApiFp(configuration)
    return {
        /**
         * Use this method to approve an specific flavor submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Approves a flavor to include it on default list methods
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveFlavor(flavorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.approveFlavor(flavorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to delete a specific flavor from the database.
         * @summary (Admins) Deletes an existing flavor
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlavor(flavorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFlavor(flavorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve a specific flavor from the database.
         * @summary (Public) Retrieves flavor details
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlavor(flavorId: string, options?: any): AxiosPromise<Flavor> {
            return localVarFp.getFlavor(flavorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve the site information from a specific flavor in the database.
         * @summary (Public) Retrieves flavor site details
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlavorSite(flavorId: string, options?: any): AxiosPromise<Site> {
            return localVarFp.getFlavorSite(flavorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method instead of DELETE as it raises 422 in case the resource was already approved.  Use this method to reject an specific flavor submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Rejects a flavor to safe delete it.
         * @param {string} flavorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFlavor(flavorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rejectFlavor(flavorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to update a specific flavor from the database.
         * @summary (Admins) Updates an existing flavor
         * @param {string} flavorId 
         * @param {Flavor} flavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlavor(flavorId: string, flavor: Flavor, options?: any): AxiosPromise<void> {
            return localVarFp.updateFlavor(flavorId, flavor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlavorsApi - object-oriented interface
 * @export
 * @class FlavorsApi
 * @extends {BaseAPI}
 */
export class FlavorsApi extends BaseAPI {
    /**
     * Use this method to approve an specific flavor submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
     * @summary (Admins) Approves a flavor to include it on default list methods
     * @param {string} flavorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public approveFlavor(flavorId: string, options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).approveFlavor(flavorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to delete a specific flavor from the database.
     * @summary (Admins) Deletes an existing flavor
     * @param {string} flavorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public deleteFlavor(flavorId: string, options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).deleteFlavor(flavorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve a specific flavor from the database.
     * @summary (Public) Retrieves flavor details
     * @param {string} flavorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public getFlavor(flavorId: string, options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).getFlavor(flavorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve the site information from a specific flavor in the database.
     * @summary (Public) Retrieves flavor site details
     * @param {string} flavorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public getFlavorSite(flavorId: string, options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).getFlavorSite(flavorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method instead of DELETE as it raises 422 in case the resource was already approved.  Use this method to reject an specific flavor submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
     * @summary (Admins) Rejects a flavor to safe delete it.
     * @param {string} flavorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public rejectFlavor(flavorId: string, options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).rejectFlavor(flavorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to update a specific flavor from the database.
     * @summary (Admins) Updates an existing flavor
     * @param {string} flavorId 
     * @param {Flavor} flavor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public updateFlavor(flavorId: string, flavor: Flavor, options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).updateFlavor(flavorId, flavor, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this method to approve an specific resource submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admin) Accepts an existing claim
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveClaim: async (reportId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('approveClaim', 'reportId', reportId)
            const localVarPath = `/reports/claims/{report_id}:approve`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve a specific claim from the database.
         * @summary (Public) Retrieves claim details
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaim: async (reportId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getClaim', 'reportId', reportId)
            const localVarPath = `/reports/claims/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of claims filtered according to your requirements. The response returns a pagination object with the filtered claims (if succeeds).
         * @summary (Admins) Filters and lists claims
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClaims: async (status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/claims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of submits filtered according to your requirements. The response returns a pagination object with the filtered submits (if succeeds).
         * @summary (Admins) Filters and list  submits
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {'benchmark' | 'claim' | 'site' | 'flavor'} [resourceType] Resource type discriminator
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubmits: async (uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, resourceType?: 'benchmark' | 'claim' | 'site' | 'flavor', sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/submits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to reject an specific resource submitted by an user. It is a custom method, as side effect, it removes the resource and the submit report associated as it is no longer needed.
         * @summary (Admin) Refuses an existing claim
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectClaim: async (reportId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('rejectClaim', 'reportId', reportId)
            const localVarPath = `/reports/claims/{report_id}:reject`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this method to approve an specific resource submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admin) Accepts an existing claim
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveClaim(reportId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveClaim(reportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve a specific claim from the database.
         * @summary (Public) Retrieves claim details
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaim(reportId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Claim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaim(reportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of claims filtered according to your requirements. The response returns a pagination object with the filtered claims (if succeeds).
         * @summary (Admins) Filters and lists claims
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClaims(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Claims>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClaims(status, uploadBefore, uploadAfter, perPage, page, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of submits filtered according to your requirements. The response returns a pagination object with the filtered submits (if succeeds).
         * @summary (Admins) Filters and list  submits
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {'benchmark' | 'claim' | 'site' | 'flavor'} [resourceType] Resource type discriminator
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubmits(uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, resourceType?: 'benchmark' | 'claim' | 'site' | 'flavor', sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Submits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubmits(uploadBefore, uploadAfter, perPage, page, resourceType, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to reject an specific resource submitted by an user. It is a custom method, as side effect, it removes the resource and the submit report associated as it is no longer needed.
         * @summary (Admin) Refuses an existing claim
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectClaim(reportId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectClaim(reportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * Use this method to approve an specific resource submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admin) Accepts an existing claim
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveClaim(reportId: string, options?: any): AxiosPromise<void> {
            return localVarFp.approveClaim(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve a specific claim from the database.
         * @summary (Public) Retrieves claim details
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaim(reportId: string, options?: any): AxiosPromise<Claim> {
            return localVarFp.getClaim(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of claims filtered according to your requirements. The response returns a pagination object with the filtered claims (if succeeds).
         * @summary (Admins) Filters and lists claims
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClaims(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options?: any): AxiosPromise<Claims> {
            return localVarFp.listClaims(status, uploadBefore, uploadAfter, perPage, page, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of submits filtered according to your requirements. The response returns a pagination object with the filtered submits (if succeeds).
         * @summary (Admins) Filters and list  submits
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {'benchmark' | 'claim' | 'site' | 'flavor'} [resourceType] Resource type discriminator
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubmits(uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, resourceType?: 'benchmark' | 'claim' | 'site' | 'flavor', sortBy?: string, options?: any): AxiosPromise<Submits> {
            return localVarFp.listSubmits(uploadBefore, uploadAfter, perPage, page, resourceType, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to reject an specific resource submitted by an user. It is a custom method, as side effect, it removes the resource and the submit report associated as it is no longer needed.
         * @summary (Admin) Refuses an existing claim
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectClaim(reportId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rejectClaim(reportId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * Use this method to approve an specific resource submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
     * @summary (Admin) Accepts an existing claim
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public approveClaim(reportId: string, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).approveClaim(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve a specific claim from the database.
     * @summary (Public) Retrieves claim details
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getClaim(reportId: string, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getClaim(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of claims filtered according to your requirements. The response returns a pagination object with the filtered claims (if succeeds).
     * @summary (Admins) Filters and lists claims
     * @param {'on_review' | 'approved'} [status] Resource current state
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public listClaims(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).listClaims(status, uploadBefore, uploadAfter, perPage, page, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of submits filtered according to your requirements. The response returns a pagination object with the filtered submits (if succeeds).
     * @summary (Admins) Filters and list  submits
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {'benchmark' | 'claim' | 'site' | 'flavor'} [resourceType] Resource type discriminator
     * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public listSubmits(uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, resourceType?: 'benchmark' | 'claim' | 'site' | 'flavor', sortBy?: string, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).listSubmits(uploadBefore, uploadAfter, perPage, page, resourceType, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to reject an specific resource submitted by an user. It is a custom method, as side effect, it removes the resource and the submit report associated as it is no longer needed.
     * @summary (Admin) Refuses an existing claim
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public rejectClaim(reportId: string, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).rejectClaim(reportId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResultsApi - axios parameter creator
 * @export
 */
export const ResultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this method to create a report for a specific result so the administrators are aware of issues. The reported result is hidden from generic responses until the issue is corrected and approved by the administrators.
         * @summary (Users) Reports a result
         * @param {string} resultId 
         * @param {CreateClaim} createClaim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimReport: async (resultId: string, createClaim: CreateClaim, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('claimReport', 'resultId', resultId)
            // verify required parameter 'createClaim' is not null or undefined
            assertParamExists('claimReport', 'createClaim', createClaim)
            const localVarPath = `/results/{result_id}:claim`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClaim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to create a new result in the database so it can be accessed by the application users. The method returns the complete created result (if succeeds).  The uploaded result must pass the benchmark JSON Schema to be accepted, otherwise 422 UnprocessableEntity is produced. In addition, an execution_datetime must be provided in order to indicate the time when the benchmark was executed. It should be in ISO8601 format and include the timezone.
         * @summary (Users) Uploads a new result
         * @param {string} executionDatetime START execution datetime and timezone of the result
         * @param {string} benchmarkId UUID benchmark unique identification
         * @param {string} flavorId UUID flavor unique identification
         * @param {{ [key: string]: any; }} requestBody 
         * @param {Array<string>} [tagsIds] UUID tags unique identifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResult: async (executionDatetime: string, benchmarkId: string, flavorId: string, requestBody: { [key: string]: any; }, tagsIds?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'executionDatetime' is not null or undefined
            assertParamExists('createResult', 'executionDatetime', executionDatetime)
            // verify required parameter 'benchmarkId' is not null or undefined
            assertParamExists('createResult', 'benchmarkId', benchmarkId)
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('createResult', 'flavorId', flavorId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('createResult', 'requestBody', requestBody)
            const localVarPath = `/results`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (executionDatetime !== undefined) {
                localVarQueryParameter['execution_datetime'] = (executionDatetime as any instanceof Date) ?
                    (executionDatetime as any).toISOString() :
                    executionDatetime;
            }

            if (benchmarkId !== undefined) {
                localVarQueryParameter['benchmark_id'] = benchmarkId;
            }

            if (flavorId !== undefined) {
                localVarQueryParameter['flavor_id'] = flavorId;
            }

            if (tagsIds) {
                localVarQueryParameter['tags_ids'] = tagsIds;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to delete a specific result from the database.
         * @summary (Admin) Deletes an existing result
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResult: async (resultId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('deleteResult', 'resultId', resultId)
            const localVarPath = `/results/{result_id}`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve a specific result from the database.
         * @summary (Public) Retrieves result details
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResult: async (resultId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('getResult', 'resultId', resultId)
            const localVarPath = `/results/{result_id}`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve all the result claims.
         * @summary (Owner or Admins) Returns the result claims.
         * @param {string} resultId 
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResultClaims: async (resultId: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('listResultClaims', 'resultId', resultId)
            const localVarPath = `/results/{result_id}/claims`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of results filtered according to your requirements. The response returns a pagination object with the filtered results (if succeeds).  This method allows to return results filtered by values inside the result. The filter is composed by 3 arguments separated by spaces (\'%20\' on URL-encoding): <path.separated.by.dots> <operator> <value>  There are five filter operators:   - **Equals (==)**: Return results where path value is exact to the    query value. For example *filters=cpu.count == 5*  - **Greater than (>)**: Return results where path value strictly    greater than the query value. For example *filters=cpu.count > 5*  - **Less than (<)**: Return results where path value strictly lower    than the query value. For example *filters=cpu.count < 5*  - **Greater or equal (>=)**: Return results where path value is equal    or greater than the query value. For example *filters=cpu.count >= 5*  - **Less or equal (<=)**: Return results where path value is equal or    lower than the query value. For example *filters=cpu.count <= 5*  Note that in the provided examples the filter is not URL-encoded as most libraries do it automatically, however there might be exception. In such cases, use the url encoding guide at: https://datatracker.ietf.org/doc/html/rfc3986#section-2.1
         * @summary (Public) Filters and list results
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [executionBefore] Results executed before date (ISO8601)
         * @param {string} [executionAfter] Results executed after date (ISO8601)
         * @param {string} [benchmarkId] UUID benchmark unique identification
         * @param {string} [siteId] UUID site unique identification
         * @param {string} [flavorId] UUID flavor unique identification
         * @param {Array<string>} [tagsIds] UUID tags unique identifications
         * @param {Array<string>} [filters] List of filter conditions (space separated)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,execution_datetime,upload_datetime].&lt;br&gt;Benchmark fields: [benchmark_id,benchmark_name].&lt;br&gt;Site fields: [site_id,site_name,site_address].&lt;br&gt;Flavor fields: [flavor_id,flavor_name].&lt;br&gt;Custom json fields using \&#39;json\&#39; and \&#39;.\&#39; as json field delimiter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResults: async (uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, executionBefore?: string, executionAfter?: string, benchmarkId?: string, siteId?: string, flavorId?: string, tagsIds?: Array<string>, filters?: Array<string>, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/results`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (executionBefore !== undefined) {
                localVarQueryParameter['execution_before'] = (executionBefore as any instanceof Date) ?
                    (executionBefore as any).toISOString().substr(0,10) :
                    executionBefore;
            }

            if (executionAfter !== undefined) {
                localVarQueryParameter['execution_after'] = (executionAfter as any instanceof Date) ?
                    (executionAfter as any).toISOString().substr(0,10) :
                    executionAfter;
            }

            if (benchmarkId !== undefined) {
                localVarQueryParameter['benchmark_id'] = benchmarkId;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (flavorId !== undefined) {
                localVarQueryParameter['flavor_id'] = flavorId;
            }

            if (tagsIds) {
                localVarQueryParameter['tags_ids'] = tagsIds;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve the uploader of a specific result from the database.
         * @summary (Admins) Retrieves result uploader
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resultUploader: async (resultId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('resultUploader', 'resultId', resultId)
            const localVarPath = `/results/{result_id}/uploader`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of results based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all results with \'v1\' and \'0\' on the \'docker_image\', \'docker_tag\', \'site_name\', \'flavor_name\' fields or \'tags\'. The response returns a pagination object with the filtered results (if succeeds).
         * @summary (Public) Filters and list results
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchResults: async (terms?: Array<string>, sortBy?: string, uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/results:search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (terms) {
                localVarQueryParameter['terms'] = terms;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to update tags on a specific result from the database.
         * @summary (Owner or Admin) Updates an existing result tags
         * @param {string} resultId 
         * @param {TagsIds} tagsIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResult: async (resultId: string, tagsIds: TagsIds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists('updateResult', 'resultId', resultId)
            // verify required parameter 'tagsIds' is not null or undefined
            assertParamExists('updateResult', 'tagsIds', tagsIds)
            const localVarPath = `/results/{result_id}/tags`
                .replace(`{${"result_id"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagsIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResultsApi - functional programming interface
 * @export
 */
export const ResultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResultsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this method to create a report for a specific result so the administrators are aware of issues. The reported result is hidden from generic responses until the issue is corrected and approved by the administrators.
         * @summary (Users) Reports a result
         * @param {string} resultId 
         * @param {CreateClaim} createClaim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimReport(resultId: string, createClaim: CreateClaim, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Claim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimReport(resultId, createClaim, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to create a new result in the database so it can be accessed by the application users. The method returns the complete created result (if succeeds).  The uploaded result must pass the benchmark JSON Schema to be accepted, otherwise 422 UnprocessableEntity is produced. In addition, an execution_datetime must be provided in order to indicate the time when the benchmark was executed. It should be in ISO8601 format and include the timezone.
         * @summary (Users) Uploads a new result
         * @param {string} executionDatetime START execution datetime and timezone of the result
         * @param {string} benchmarkId UUID benchmark unique identification
         * @param {string} flavorId UUID flavor unique identification
         * @param {{ [key: string]: any; }} requestBody 
         * @param {Array<string>} [tagsIds] UUID tags unique identifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResult(executionDatetime: string, benchmarkId: string, flavorId: string, requestBody: { [key: string]: any; }, tagsIds?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResult(executionDatetime, benchmarkId, flavorId, requestBody, tagsIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to delete a specific result from the database.
         * @summary (Admin) Deletes an existing result
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResult(resultId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResult(resultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve a specific result from the database.
         * @summary (Public) Retrieves result details
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResult(resultId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResult(resultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve all the result claims.
         * @summary (Owner or Admins) Returns the result claims.
         * @param {string} resultId 
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResultClaims(resultId: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Claims>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResultClaims(resultId, status, uploadBefore, uploadAfter, perPage, page, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of results filtered according to your requirements. The response returns a pagination object with the filtered results (if succeeds).  This method allows to return results filtered by values inside the result. The filter is composed by 3 arguments separated by spaces (\'%20\' on URL-encoding): <path.separated.by.dots> <operator> <value>  There are five filter operators:   - **Equals (==)**: Return results where path value is exact to the    query value. For example *filters=cpu.count == 5*  - **Greater than (>)**: Return results where path value strictly    greater than the query value. For example *filters=cpu.count > 5*  - **Less than (<)**: Return results where path value strictly lower    than the query value. For example *filters=cpu.count < 5*  - **Greater or equal (>=)**: Return results where path value is equal    or greater than the query value. For example *filters=cpu.count >= 5*  - **Less or equal (<=)**: Return results where path value is equal or    lower than the query value. For example *filters=cpu.count <= 5*  Note that in the provided examples the filter is not URL-encoded as most libraries do it automatically, however there might be exception. In such cases, use the url encoding guide at: https://datatracker.ietf.org/doc/html/rfc3986#section-2.1
         * @summary (Public) Filters and list results
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [executionBefore] Results executed before date (ISO8601)
         * @param {string} [executionAfter] Results executed after date (ISO8601)
         * @param {string} [benchmarkId] UUID benchmark unique identification
         * @param {string} [siteId] UUID site unique identification
         * @param {string} [flavorId] UUID flavor unique identification
         * @param {Array<string>} [tagsIds] UUID tags unique identifications
         * @param {Array<string>} [filters] List of filter conditions (space separated)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,execution_datetime,upload_datetime].&lt;br&gt;Benchmark fields: [benchmark_id,benchmark_name].&lt;br&gt;Site fields: [site_id,site_name,site_address].&lt;br&gt;Flavor fields: [flavor_id,flavor_name].&lt;br&gt;Custom json fields using \&#39;json\&#39; and \&#39;.\&#39; as json field delimiter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResults(uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, executionBefore?: string, executionAfter?: string, benchmarkId?: string, siteId?: string, flavorId?: string, tagsIds?: Array<string>, filters?: Array<string>, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Results>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResults(uploadBefore, uploadAfter, perPage, page, executionBefore, executionAfter, benchmarkId, siteId, flavorId, tagsIds, filters, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve the uploader of a specific result from the database.
         * @summary (Admins) Retrieves result uploader
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resultUploader(resultId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resultUploader(resultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of results based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all results with \'v1\' and \'0\' on the \'docker_image\', \'docker_tag\', \'site_name\', \'flavor_name\' fields or \'tags\'. The response returns a pagination object with the filtered results (if succeeds).
         * @summary (Public) Filters and list results
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchResults(terms?: Array<string>, sortBy?: string, uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Results>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchResults(terms, sortBy, uploadBefore, uploadAfter, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to update tags on a specific result from the database.
         * @summary (Owner or Admin) Updates an existing result tags
         * @param {string} resultId 
         * @param {TagsIds} tagsIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResult(resultId: string, tagsIds: TagsIds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResult(resultId, tagsIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResultsApi - factory interface
 * @export
 */
export const ResultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResultsApiFp(configuration)
    return {
        /**
         * Use this method to create a report for a specific result so the administrators are aware of issues. The reported result is hidden from generic responses until the issue is corrected and approved by the administrators.
         * @summary (Users) Reports a result
         * @param {string} resultId 
         * @param {CreateClaim} createClaim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimReport(resultId: string, createClaim: CreateClaim, options?: any): AxiosPromise<Claim> {
            return localVarFp.claimReport(resultId, createClaim, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to create a new result in the database so it can be accessed by the application users. The method returns the complete created result (if succeeds).  The uploaded result must pass the benchmark JSON Schema to be accepted, otherwise 422 UnprocessableEntity is produced. In addition, an execution_datetime must be provided in order to indicate the time when the benchmark was executed. It should be in ISO8601 format and include the timezone.
         * @summary (Users) Uploads a new result
         * @param {string} executionDatetime START execution datetime and timezone of the result
         * @param {string} benchmarkId UUID benchmark unique identification
         * @param {string} flavorId UUID flavor unique identification
         * @param {{ [key: string]: any; }} requestBody 
         * @param {Array<string>} [tagsIds] UUID tags unique identifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResult(executionDatetime: string, benchmarkId: string, flavorId: string, requestBody: { [key: string]: any; }, tagsIds?: Array<string>, options?: any): AxiosPromise<Result> {
            return localVarFp.createResult(executionDatetime, benchmarkId, flavorId, requestBody, tagsIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to delete a specific result from the database.
         * @summary (Admin) Deletes an existing result
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResult(resultId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteResult(resultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve a specific result from the database.
         * @summary (Public) Retrieves result details
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResult(resultId: string, options?: any): AxiosPromise<Result> {
            return localVarFp.getResult(resultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve all the result claims.
         * @summary (Owner or Admins) Returns the result claims.
         * @param {string} resultId 
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResultClaims(resultId: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options?: any): AxiosPromise<Claims> {
            return localVarFp.listResultClaims(resultId, status, uploadBefore, uploadAfter, perPage, page, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of results filtered according to your requirements. The response returns a pagination object with the filtered results (if succeeds).  This method allows to return results filtered by values inside the result. The filter is composed by 3 arguments separated by spaces (\'%20\' on URL-encoding): <path.separated.by.dots> <operator> <value>  There are five filter operators:   - **Equals (==)**: Return results where path value is exact to the    query value. For example *filters=cpu.count == 5*  - **Greater than (>)**: Return results where path value strictly    greater than the query value. For example *filters=cpu.count > 5*  - **Less than (<)**: Return results where path value strictly lower    than the query value. For example *filters=cpu.count < 5*  - **Greater or equal (>=)**: Return results where path value is equal    or greater than the query value. For example *filters=cpu.count >= 5*  - **Less or equal (<=)**: Return results where path value is equal or    lower than the query value. For example *filters=cpu.count <= 5*  Note that in the provided examples the filter is not URL-encoded as most libraries do it automatically, however there might be exception. In such cases, use the url encoding guide at: https://datatracker.ietf.org/doc/html/rfc3986#section-2.1
         * @summary (Public) Filters and list results
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [executionBefore] Results executed before date (ISO8601)
         * @param {string} [executionAfter] Results executed after date (ISO8601)
         * @param {string} [benchmarkId] UUID benchmark unique identification
         * @param {string} [siteId] UUID site unique identification
         * @param {string} [flavorId] UUID flavor unique identification
         * @param {Array<string>} [tagsIds] UUID tags unique identifications
         * @param {Array<string>} [filters] List of filter conditions (space separated)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,execution_datetime,upload_datetime].&lt;br&gt;Benchmark fields: [benchmark_id,benchmark_name].&lt;br&gt;Site fields: [site_id,site_name,site_address].&lt;br&gt;Flavor fields: [flavor_id,flavor_name].&lt;br&gt;Custom json fields using \&#39;json\&#39; and \&#39;.\&#39; as json field delimiter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResults(uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, executionBefore?: string, executionAfter?: string, benchmarkId?: string, siteId?: string, flavorId?: string, tagsIds?: Array<string>, filters?: Array<string>, sortBy?: string, options?: any): AxiosPromise<Results> {
            return localVarFp.listResults(uploadBefore, uploadAfter, perPage, page, executionBefore, executionAfter, benchmarkId, siteId, flavorId, tagsIds, filters, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve the uploader of a specific result from the database.
         * @summary (Admins) Retrieves result uploader
         * @param {string} resultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resultUploader(resultId: string, options?: any): AxiosPromise<User> {
            return localVarFp.resultUploader(resultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of results based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all results with \'v1\' and \'0\' on the \'docker_image\', \'docker_tag\', \'site_name\', \'flavor_name\' fields or \'tags\'. The response returns a pagination object with the filtered results (if succeeds).
         * @summary (Public) Filters and list results
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchResults(terms?: Array<string>, sortBy?: string, uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: any): AxiosPromise<Results> {
            return localVarFp.searchResults(terms, sortBy, uploadBefore, uploadAfter, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to update tags on a specific result from the database.
         * @summary (Owner or Admin) Updates an existing result tags
         * @param {string} resultId 
         * @param {TagsIds} tagsIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResult(resultId: string, tagsIds: TagsIds, options?: any): AxiosPromise<void> {
            return localVarFp.updateResult(resultId, tagsIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResultsApi - object-oriented interface
 * @export
 * @class ResultsApi
 * @extends {BaseAPI}
 */
export class ResultsApi extends BaseAPI {
    /**
     * Use this method to create a report for a specific result so the administrators are aware of issues. The reported result is hidden from generic responses until the issue is corrected and approved by the administrators.
     * @summary (Users) Reports a result
     * @param {string} resultId 
     * @param {CreateClaim} createClaim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public claimReport(resultId: string, createClaim: CreateClaim, options?: AxiosRequestConfig) {
        return ResultsApiFp(this.configuration).claimReport(resultId, createClaim, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to create a new result in the database so it can be accessed by the application users. The method returns the complete created result (if succeeds).  The uploaded result must pass the benchmark JSON Schema to be accepted, otherwise 422 UnprocessableEntity is produced. In addition, an execution_datetime must be provided in order to indicate the time when the benchmark was executed. It should be in ISO8601 format and include the timezone.
     * @summary (Users) Uploads a new result
     * @param {string} executionDatetime START execution datetime and timezone of the result
     * @param {string} benchmarkId UUID benchmark unique identification
     * @param {string} flavorId UUID flavor unique identification
     * @param {{ [key: string]: any; }} requestBody 
     * @param {Array<string>} [tagsIds] UUID tags unique identifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public createResult(executionDatetime: string, benchmarkId: string, flavorId: string, requestBody: { [key: string]: any; }, tagsIds?: Array<string>, options?: AxiosRequestConfig) {
        return ResultsApiFp(this.configuration).createResult(executionDatetime, benchmarkId, flavorId, requestBody, tagsIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to delete a specific result from the database.
     * @summary (Admin) Deletes an existing result
     * @param {string} resultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public deleteResult(resultId: string, options?: AxiosRequestConfig) {
        return ResultsApiFp(this.configuration).deleteResult(resultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve a specific result from the database.
     * @summary (Public) Retrieves result details
     * @param {string} resultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public getResult(resultId: string, options?: AxiosRequestConfig) {
        return ResultsApiFp(this.configuration).getResult(resultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve all the result claims.
     * @summary (Owner or Admins) Returns the result claims.
     * @param {string} resultId 
     * @param {'on_review' | 'approved'} [status] Resource current state
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public listResultClaims(resultId: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options?: AxiosRequestConfig) {
        return ResultsApiFp(this.configuration).listResultClaims(resultId, status, uploadBefore, uploadAfter, perPage, page, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of results filtered according to your requirements. The response returns a pagination object with the filtered results (if succeeds).  This method allows to return results filtered by values inside the result. The filter is composed by 3 arguments separated by spaces (\'%20\' on URL-encoding): <path.separated.by.dots> <operator> <value>  There are five filter operators:   - **Equals (==)**: Return results where path value is exact to the    query value. For example *filters=cpu.count == 5*  - **Greater than (>)**: Return results where path value strictly    greater than the query value. For example *filters=cpu.count > 5*  - **Less than (<)**: Return results where path value strictly lower    than the query value. For example *filters=cpu.count < 5*  - **Greater or equal (>=)**: Return results where path value is equal    or greater than the query value. For example *filters=cpu.count >= 5*  - **Less or equal (<=)**: Return results where path value is equal or    lower than the query value. For example *filters=cpu.count <= 5*  Note that in the provided examples the filter is not URL-encoded as most libraries do it automatically, however there might be exception. In such cases, use the url encoding guide at: https://datatracker.ietf.org/doc/html/rfc3986#section-2.1
     * @summary (Public) Filters and list results
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {string} [executionBefore] Results executed before date (ISO8601)
     * @param {string} [executionAfter] Results executed after date (ISO8601)
     * @param {string} [benchmarkId] UUID benchmark unique identification
     * @param {string} [siteId] UUID site unique identification
     * @param {string} [flavorId] UUID flavor unique identification
     * @param {Array<string>} [tagsIds] UUID tags unique identifications
     * @param {Array<string>} [filters] List of filter conditions (space separated)
     * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,execution_datetime,upload_datetime].&lt;br&gt;Benchmark fields: [benchmark_id,benchmark_name].&lt;br&gt;Site fields: [site_id,site_name,site_address].&lt;br&gt;Flavor fields: [flavor_id,flavor_name].&lt;br&gt;Custom json fields using \&#39;json\&#39; and \&#39;.\&#39; as json field delimiter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public listResults(uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, executionBefore?: string, executionAfter?: string, benchmarkId?: string, siteId?: string, flavorId?: string, tagsIds?: Array<string>, filters?: Array<string>, sortBy?: string, options?: AxiosRequestConfig) {
        return ResultsApiFp(this.configuration).listResults(uploadBefore, uploadAfter, perPage, page, executionBefore, executionAfter, benchmarkId, siteId, flavorId, tagsIds, filters, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve the uploader of a specific result from the database.
     * @summary (Admins) Retrieves result uploader
     * @param {string} resultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public resultUploader(resultId: string, options?: AxiosRequestConfig) {
        return ResultsApiFp(this.configuration).resultUploader(resultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of results based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all results with \'v1\' and \'0\' on the \'docker_image\', \'docker_tag\', \'site_name\', \'flavor_name\' fields or \'tags\'. The response returns a pagination object with the filtered results (if succeeds).
     * @summary (Public) Filters and list results
     * @param {Array<string>} [terms] List of terms (string subsets)
     * @param {string} [sortBy] Order to return the results (coma separated)
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public searchResults(terms?: Array<string>, sortBy?: string, uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: AxiosRequestConfig) {
        return ResultsApiFp(this.configuration).searchResults(terms, sortBy, uploadBefore, uploadAfter, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to update tags on a specific result from the database.
     * @summary (Owner or Admin) Updates an existing result tags
     * @param {string} resultId 
     * @param {TagsIds} tagsIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    public updateResult(resultId: string, tagsIds: TagsIds, options?: AxiosRequestConfig) {
        return ResultsApiFp(this.configuration).updateResult(resultId, tagsIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SitesApi - axios parameter creator
 * @export
 */
export const SitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this method to create a new flavors in the database so it can be accessed by the application users. The method returns the complete created flavor (if succeeds).
         * @summary (Users) Uploads a new flavor
         * @param {string} siteId 
         * @param {CreateFlavor} createFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFlavor: async (siteId: string, createFlavor: CreateFlavor, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('addFlavor', 'siteId', siteId)
            // verify required parameter 'createFlavor' is not null or undefined
            assertParamExists('addFlavor', 'createFlavor', createFlavor)
            const localVarPath = `/sites/{site_id}/flavors`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFlavor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to approve an specific site submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Approves a site to include it on default list methods
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveSite: async (siteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('approveSite', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}:approve`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to create a new site in the database so it can be accessed by the application users. The method returns the complete created site (if succeeds).
         * @summary (Users) Uploads a new site
         * @param {CreateSite} createSite 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSite: async (createSite: CreateSite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSite' is not null or undefined
            assertParamExists('createSite', 'createSite', createSite)
            const localVarPath = `/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to delete a specific site from the database.
         * @summary (Admins) Deletes an existing site
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSite: async (siteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('deleteSite', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve a specific site from the database.
         * @summary (Public) Retrieves site details
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSite: async (siteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('getSite', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of flavors filtered according to your requirements. The response returns a pagination object with the filtered flavors (if succeeds).
         * @summary (Public) Filters and list flavors
         * @param {string} siteId 
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [name] String with virtual hardware template identification
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors: async (siteId: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, name?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('listFlavors', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/flavors`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of sites filtered according to your requirements. The response returns a pagination object with the filtered sites (if succeeds).
         * @summary (Public) Filters and list sites
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [name] String with human readable institution identification
         * @param {string} [address] String with place where a site is located
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name,address]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSites: async (status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, name?: string, address?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method instead of DELETE as it raises 422 in case the resource was already approved.  Use this method to reject an specific site submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Rejects a site to safe delete it.
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectSite: async (siteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('rejectSite', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}:reject`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of flavors based on a general search of terms. For example, calling this method with terms=K&terms=T returns all flavors with \'K\' and \'T\' on the \'name\', or \'description\' fields. The response returns a pagination object with the filtered flavors (if succeeds).
         * @summary (Public) Filters and list flavors
         * @param {string} siteId 
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlavor: async (siteId: string, terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('searchFlavor', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/flavors:search`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (terms) {
                localVarQueryParameter['terms'] = terms;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of sites based on a general search of terms. For example, calling this method with terms=K&terms=T returns all sites with \'K\' and \'T\' on the \'name\', \'address\', or \'description\' fields. The response returns a pagination object with the filtered sites (if succeeds).
         * @summary (Public) Filters and list sites
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSites: async (terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sites:search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (terms) {
                localVarQueryParameter['terms'] = terms;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to update a specific site from the database.
         * @summary (Admins) Updates an existing site
         * @param {string} siteId 
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSite: async (siteId: string, site: Site, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('updateSite', 'siteId', siteId)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('updateSite', 'site', site)
            const localVarPath = `/sites/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SitesApi - functional programming interface
 * @export
 */
export const SitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SitesApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this method to create a new flavors in the database so it can be accessed by the application users. The method returns the complete created flavor (if succeeds).
         * @summary (Users) Uploads a new flavor
         * @param {string} siteId 
         * @param {CreateFlavor} createFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFlavor(siteId: string, createFlavor: CreateFlavor, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFlavor(siteId, createFlavor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to approve an specific site submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Approves a site to include it on default list methods
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveSite(siteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveSite(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to create a new site in the database so it can be accessed by the application users. The method returns the complete created site (if succeeds).
         * @summary (Users) Uploads a new site
         * @param {CreateSite} createSite 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSite(createSite: CreateSite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSite(createSite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to delete a specific site from the database.
         * @summary (Admins) Deletes an existing site
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSite(siteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSite(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve a specific site from the database.
         * @summary (Public) Retrieves site details
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSite(siteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSite(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of flavors filtered according to your requirements. The response returns a pagination object with the filtered flavors (if succeeds).
         * @summary (Public) Filters and list flavors
         * @param {string} siteId 
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [name] String with virtual hardware template identification
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFlavors(siteId: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, name?: string, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavors>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFlavors(siteId, status, uploadBefore, uploadAfter, perPage, page, name, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of sites filtered according to your requirements. The response returns a pagination object with the filtered sites (if succeeds).
         * @summary (Public) Filters and list sites
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [name] String with human readable institution identification
         * @param {string} [address] String with place where a site is located
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name,address]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSites(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, name?: string, address?: string, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sites>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSites(status, uploadBefore, uploadAfter, perPage, page, name, address, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method instead of DELETE as it raises 422 in case the resource was already approved.  Use this method to reject an specific site submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Rejects a site to safe delete it.
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectSite(siteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectSite(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of flavors based on a general search of terms. For example, calling this method with terms=K&terms=T returns all flavors with \'K\' and \'T\' on the \'name\', or \'description\' fields. The response returns a pagination object with the filtered flavors (if succeeds).
         * @summary (Public) Filters and list flavors
         * @param {string} siteId 
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFlavor(siteId: string, terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavors>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFlavor(siteId, terms, sortBy, status, uploadBefore, uploadAfter, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of sites based on a general search of terms. For example, calling this method with terms=K&terms=T returns all sites with \'K\' and \'T\' on the \'name\', \'address\', or \'description\' fields. The response returns a pagination object with the filtered sites (if succeeds).
         * @summary (Public) Filters and list sites
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSites(terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sites>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSites(terms, sortBy, status, uploadBefore, uploadAfter, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to update a specific site from the database.
         * @summary (Admins) Updates an existing site
         * @param {string} siteId 
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSite(siteId: string, site: Site, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSite(siteId, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SitesApi - factory interface
 * @export
 */
export const SitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SitesApiFp(configuration)
    return {
        /**
         * Use this method to create a new flavors in the database so it can be accessed by the application users. The method returns the complete created flavor (if succeeds).
         * @summary (Users) Uploads a new flavor
         * @param {string} siteId 
         * @param {CreateFlavor} createFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFlavor(siteId: string, createFlavor: CreateFlavor, options?: any): AxiosPromise<Flavor> {
            return localVarFp.addFlavor(siteId, createFlavor, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to approve an specific site submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Approves a site to include it on default list methods
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveSite(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.approveSite(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to create a new site in the database so it can be accessed by the application users. The method returns the complete created site (if succeeds).
         * @summary (Users) Uploads a new site
         * @param {CreateSite} createSite 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSite(createSite: CreateSite, options?: any): AxiosPromise<Site> {
            return localVarFp.createSite(createSite, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to delete a specific site from the database.
         * @summary (Admins) Deletes an existing site
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSite(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSite(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve a specific site from the database.
         * @summary (Public) Retrieves site details
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSite(siteId: string, options?: any): AxiosPromise<Site> {
            return localVarFp.getSite(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of flavors filtered according to your requirements. The response returns a pagination object with the filtered flavors (if succeeds).
         * @summary (Public) Filters and list flavors
         * @param {string} siteId 
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [name] String with virtual hardware template identification
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors(siteId: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, name?: string, sortBy?: string, options?: any): AxiosPromise<Flavors> {
            return localVarFp.listFlavors(siteId, status, uploadBefore, uploadAfter, perPage, page, name, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of sites filtered according to your requirements. The response returns a pagination object with the filtered sites (if succeeds).
         * @summary (Public) Filters and list sites
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [name] String with human readable institution identification
         * @param {string} [address] String with place where a site is located
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name,address]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSites(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, name?: string, address?: string, sortBy?: string, options?: any): AxiosPromise<Sites> {
            return localVarFp.listSites(status, uploadBefore, uploadAfter, perPage, page, name, address, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method instead of DELETE as it raises 422 in case the resource was already approved.  Use this method to reject an specific site submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
         * @summary (Admins) Rejects a site to safe delete it.
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectSite(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rejectSite(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of flavors based on a general search of terms. For example, calling this method with terms=K&terms=T returns all flavors with \'K\' and \'T\' on the \'name\', or \'description\' fields. The response returns a pagination object with the filtered flavors (if succeeds).
         * @summary (Public) Filters and list flavors
         * @param {string} siteId 
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlavor(siteId: string, terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: any): AxiosPromise<Flavors> {
            return localVarFp.searchFlavor(siteId, terms, sortBy, status, uploadBefore, uploadAfter, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of sites based on a general search of terms. For example, calling this method with terms=K&terms=T returns all sites with \'K\' and \'T\' on the \'name\', \'address\', or \'description\' fields. The response returns a pagination object with the filtered sites (if succeeds).
         * @summary (Public) Filters and list sites
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSites(terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: any): AxiosPromise<Sites> {
            return localVarFp.searchSites(terms, sortBy, status, uploadBefore, uploadAfter, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to update a specific site from the database.
         * @summary (Admins) Updates an existing site
         * @param {string} siteId 
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSite(siteId: string, site: Site, options?: any): AxiosPromise<void> {
            return localVarFp.updateSite(siteId, site, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SitesApi - object-oriented interface
 * @export
 * @class SitesApi
 * @extends {BaseAPI}
 */
export class SitesApi extends BaseAPI {
    /**
     * Use this method to create a new flavors in the database so it can be accessed by the application users. The method returns the complete created flavor (if succeeds).
     * @summary (Users) Uploads a new flavor
     * @param {string} siteId 
     * @param {CreateFlavor} createFlavor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public addFlavor(siteId: string, createFlavor: CreateFlavor, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).addFlavor(siteId, createFlavor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to approve an specific site submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
     * @summary (Admins) Approves a site to include it on default list methods
     * @param {string} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public approveSite(siteId: string, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).approveSite(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to create a new site in the database so it can be accessed by the application users. The method returns the complete created site (if succeeds).
     * @summary (Users) Uploads a new site
     * @param {CreateSite} createSite 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public createSite(createSite: CreateSite, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).createSite(createSite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to delete a specific site from the database.
     * @summary (Admins) Deletes an existing site
     * @param {string} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public deleteSite(siteId: string, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).deleteSite(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve a specific site from the database.
     * @summary (Public) Retrieves site details
     * @param {string} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public getSite(siteId: string, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).getSite(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of flavors filtered according to your requirements. The response returns a pagination object with the filtered flavors (if succeeds).
     * @summary (Public) Filters and list flavors
     * @param {string} siteId 
     * @param {'on_review' | 'approved'} [status] Resource current state
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {string} [name] String with virtual hardware template identification
     * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public listFlavors(siteId: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, name?: string, sortBy?: string, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).listFlavors(siteId, status, uploadBefore, uploadAfter, perPage, page, name, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of sites filtered according to your requirements. The response returns a pagination object with the filtered sites (if succeeds).
     * @summary (Public) Filters and list sites
     * @param {'on_review' | 'approved'} [status] Resource current state
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {string} [name] String with human readable institution identification
     * @param {string} [address] String with place where a site is located
     * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name,address]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public listSites(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, name?: string, address?: string, sortBy?: string, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).listSites(status, uploadBefore, uploadAfter, perPage, page, name, address, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method instead of DELETE as it raises 422 in case the resource was already approved.  Use this method to reject an specific site submitted by an user. It is a custom method, as side effect, it removes the submit report associated as it is no longer needed.
     * @summary (Admins) Rejects a site to safe delete it.
     * @param {string} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public rejectSite(siteId: string, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).rejectSite(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of flavors based on a general search of terms. For example, calling this method with terms=K&terms=T returns all flavors with \'K\' and \'T\' on the \'name\', or \'description\' fields. The response returns a pagination object with the filtered flavors (if succeeds).
     * @summary (Public) Filters and list flavors
     * @param {string} siteId 
     * @param {Array<string>} [terms] List of terms (string subsets)
     * @param {string} [sortBy] Order to return the results (coma separated)
     * @param {'on_review' | 'approved'} [status] Resource current state
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public searchFlavor(siteId: string, terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).searchFlavor(siteId, terms, sortBy, status, uploadBefore, uploadAfter, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of sites based on a general search of terms. For example, calling this method with terms=K&terms=T returns all sites with \'K\' and \'T\' on the \'name\', \'address\', or \'description\' fields. The response returns a pagination object with the filtered sites (if succeeds).
     * @summary (Public) Filters and list sites
     * @param {Array<string>} [terms] List of terms (string subsets)
     * @param {string} [sortBy] Order to return the results (coma separated)
     * @param {'on_review' | 'approved'} [status] Resource current state
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public searchSites(terms?: Array<string>, sortBy?: string, status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).searchSites(terms, sortBy, status, uploadBefore, uploadAfter, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to update a specific site from the database.
     * @summary (Admins) Updates an existing site
     * @param {string} siteId 
     * @param {Site} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public updateSite(siteId: string, site: Site, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).updateSite(siteId, site, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this method to create a new tags in the database so it can be accessed by the application users. The method returns the complete created tag (if succeeds).
         * @summary (Users) Uploads a new tag
         * @param {CreateTag} createTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (createTag: CreateTag, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTag' is not null or undefined
            assertParamExists('createTag', 'createTag', createTag)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to delete a specific tag from the database.
         * @summary (Admins) Deletes an existing tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tagId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteTag', 'tagId', tagId)
            const localVarPath = `/tags/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve a specific tag from the database.
         * @summary (Public) Retrieves tag details
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag: async (tagId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('getTag', 'tagId', tagId)
            const localVarPath = `/tags/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of tags filtered according to your requirements. The response returns a pagination object with the filtered tags (if succeeds).
         * @summary (Public) Filters and list tags
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [name] String with short feature identification
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags: async (perPage?: number, page?: number, name?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of tags based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all tags with \'v1\' and \'0\' on the \'name\' or \'description\' fields. The response returns a pagination object with the filtered tags (if succeeds).
         * @summary (Public) Filters and list tags
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTag: async (terms?: Array<string>, sortBy?: string, perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags:search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (terms) {
                localVarQueryParameter['terms'] = terms;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to update a specific tag from the database.
         * @summary (Admins) Updates an existing tag
         * @param {string} tagId 
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (tagId: string, tag: Tag, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('updateTag', 'tagId', tagId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('updateTag', 'tag', tag)
            const localVarPath = `/tags/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this method to create a new tags in the database so it can be accessed by the application users. The method returns the complete created tag (if succeeds).
         * @summary (Users) Uploads a new tag
         * @param {CreateTag} createTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(createTag: CreateTag, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(createTag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to delete a specific tag from the database.
         * @summary (Admins) Deletes an existing tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tagId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve a specific tag from the database.
         * @summary (Public) Retrieves tag details
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTag(tagId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTag(tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of tags filtered according to your requirements. The response returns a pagination object with the filtered tags (if succeeds).
         * @summary (Public) Filters and list tags
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [name] String with short feature identification
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTags(perPage?: number, page?: number, name?: string, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTags(perPage, page, name, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of tags based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all tags with \'v1\' and \'0\' on the \'name\' or \'description\' fields. The response returns a pagination object with the filtered tags (if succeeds).
         * @summary (Public) Filters and list tags
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTag(terms?: Array<string>, sortBy?: string, perPage?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTag(terms, sortBy, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to update a specific tag from the database.
         * @summary (Admins) Updates an existing tag
         * @param {string} tagId 
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(tagId: string, tag: Tag, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(tagId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Use this method to create a new tags in the database so it can be accessed by the application users. The method returns the complete created tag (if succeeds).
         * @summary (Users) Uploads a new tag
         * @param {CreateTag} createTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(createTag: CreateTag, options?: any): AxiosPromise<Tag> {
            return localVarFp.createTag(createTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to delete a specific tag from the database.
         * @summary (Admins) Deletes an existing tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve a specific tag from the database.
         * @summary (Public) Retrieves tag details
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.getTag(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of tags filtered according to your requirements. The response returns a pagination object with the filtered tags (if succeeds).
         * @summary (Public) Filters and list tags
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [name] String with short feature identification
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(perPage?: number, page?: number, name?: string, sortBy?: string, options?: any): AxiosPromise<Tags> {
            return localVarFp.listTags(perPage, page, name, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of tags based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all tags with \'v1\' and \'0\' on the \'name\' or \'description\' fields. The response returns a pagination object with the filtered tags (if succeeds).
         * @summary (Public) Filters and list tags
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTag(terms?: Array<string>, sortBy?: string, perPage?: number, page?: number, options?: any): AxiosPromise<Tags> {
            return localVarFp.searchTag(terms, sortBy, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to update a specific tag from the database.
         * @summary (Admins) Updates an existing tag
         * @param {string} tagId 
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(tagId: string, tag: Tag, options?: any): AxiosPromise<void> {
            return localVarFp.updateTag(tagId, tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Use this method to create a new tags in the database so it can be accessed by the application users. The method returns the complete created tag (if succeeds).
     * @summary (Users) Uploads a new tag
     * @param {CreateTag} createTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createTag(createTag: CreateTag, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).createTag(createTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to delete a specific tag from the database.
     * @summary (Admins) Deletes an existing tag
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(tagId: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTag(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve a specific tag from the database.
     * @summary (Public) Retrieves tag details
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTag(tagId: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTag(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of tags filtered according to your requirements. The response returns a pagination object with the filtered tags (if succeeds).
     * @summary (Public) Filters and list tags
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {string} [name] String with short feature identification
     * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,upload_datetime]&lt;br&gt;Specific fields: [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTags(perPage?: number, page?: number, name?: string, sortBy?: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).listTags(perPage, page, name, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of tags based on a general search of terms. For example, calling this method with terms=v1&terms=0 returns all tags with \'v1\' and \'0\' on the \'name\' or \'description\' fields. The response returns a pagination object with the filtered tags (if succeeds).
     * @summary (Public) Filters and list tags
     * @param {Array<string>} [terms] List of terms (string subsets)
     * @param {string} [sortBy] Order to return the results (coma separated)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public searchTag(terms?: Array<string>, sortBy?: string, perPage?: number, page?: number, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).searchTag(terms, sortBy, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to update a specific tag from the database.
     * @summary (Admins) Updates an existing tag
     * @param {string} tagId 
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTag(tagId: string, tag: Tag, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTag(tagId, tag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this method to retrieve your user data stored in the database.
         * @summary (Users) Retrieves the logged in user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelf: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/self`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve all the claims uploaded by your user.
         * @summary (Users) Returns your uploaded pending claims
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserClaims: async (status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/self/claims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve all the results uploaded by your user. You can use the query parameter to retrieve also those with pending claims.
         * @summary (Users) Returns your uploaded results
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [executionBefore] Results executed before date (ISO8601)
         * @param {string} [executionAfter] Results executed after date (ISO8601)
         * @param {string} [benchmarkId] UUID benchmark unique identification
         * @param {string} [siteId] UUID site unique identification
         * @param {string} [flavorId] UUID flavor unique identification
         * @param {Array<string>} [tagsIds] UUID tags unique identifications
         * @param {Array<string>} [filters] List of filter conditions (space separated)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,execution_datetime,upload_datetime].&lt;br&gt;Benchmark fields: [benchmark_id,benchmark_name].&lt;br&gt;Site fields: [site_id,site_name,site_address].&lt;br&gt;Flavor fields: [flavor_id,flavor_name].&lt;br&gt;Custom json fields using \&#39;json\&#39; and \&#39;.\&#39; as json field delimiter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserResults: async (uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, executionBefore?: string, executionAfter?: string, benchmarkId?: string, siteId?: string, flavorId?: string, tagsIds?: Array<string>, filters?: Array<string>, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/self/results`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (uploadBefore !== undefined) {
                localVarQueryParameter['upload_before'] = (uploadBefore as any instanceof Date) ?
                    (uploadBefore as any).toISOString().substr(0,10) :
                    uploadBefore;
            }

            if (uploadAfter !== undefined) {
                localVarQueryParameter['upload_after'] = (uploadAfter as any instanceof Date) ?
                    (uploadAfter as any).toISOString().substr(0,10) :
                    uploadAfter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (executionBefore !== undefined) {
                localVarQueryParameter['execution_before'] = (executionBefore as any instanceof Date) ?
                    (executionBefore as any).toISOString().substr(0,10) :
                    executionBefore;
            }

            if (executionAfter !== undefined) {
                localVarQueryParameter['execution_after'] = (executionAfter as any instanceof Date) ?
                    (executionAfter as any).toISOString().substr(0,10) :
                    executionAfter;
            }

            if (benchmarkId !== undefined) {
                localVarQueryParameter['benchmark_id'] = benchmarkId;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (flavorId !== undefined) {
                localVarQueryParameter['flavor_id'] = flavorId;
            }

            if (tagsIds) {
                localVarQueryParameter['tags_ids'] = tagsIds;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of users filtered according to your requirements. The response returns a pagination object with the filtered users (if succeeds).
         * @summary (Admins) Filters and list users
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sub] String containing an OIDC subject
         * @param {string} [iss] String containing an OIDC issuer
         * @param {string} [email] Email of user collected by the OIDC token
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Specific fields: [sub,iss,email,registration_datetime]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (perPage?: number, page?: number, sub?: string, iss?: string, email?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sub !== undefined) {
                localVarQueryParameter['sub'] = sub;
            }

            if (iss !== undefined) {
                localVarQueryParameter['iss'] = iss;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to register yourself into the application. By using this method, you recognize that you have read and understood our terms, conditions and privacy policy at: `https://performance.services.fedcloud.eu/privacy_policy`  The method will return your stored information.
         * @summary (OIDC Token) Registers the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSelf: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users:register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to delete the users filtered according to your requirements. To prevent unintentionally delete all users, the method requires of query arguments, otherwise UnprocessableEntity exception is raised.
         * @summary (Admins) Removes one or multiple users
         * @param {string} [sub] String containing an OIDC subject
         * @param {string} [iss] String containing an OIDC issuer
         * @param {string} [email] Email of user collected by the OIDC token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUsers: async (sub?: string, iss?: string, email?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users:remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sub !== undefined) {
                localVarQueryParameter['sub'] = sub;
            }

            if (iss !== undefined) {
                localVarQueryParameter['iss'] = iss;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of users based on a general search of terms. For example, calling this method with terms=@hotmail&terms=de returns all users with \'hotmail\' and \'de\' on the \'email\'. The response returns a pagination object with the filtered users (if succeeds).
         * @summary (Admins) Filters and list users
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (terms?: Array<string>, sortBy?: string, perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users:search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (terms) {
                localVarQueryParameter['terms'] = terms;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to check that you have the administration rights. If so, the access returns 204, otherwise 401 or 403 are expected.
         * @summary (Admins) Returns 204 if you are admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryAdmin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/self:try_admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to update your user data in the database. The method returns by default 204, use a GET method to retrieve the new status of your data.
         * @summary (Users) Updates the logged in user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSelf: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/self:update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this method to retrieve your user data stored in the database.
         * @summary (Users) Retrieves the logged in user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSelf(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSelf(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve all the claims uploaded by your user.
         * @summary (Users) Returns your uploaded pending claims
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserClaims(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Claims>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserClaims(status, uploadBefore, uploadAfter, perPage, page, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve all the results uploaded by your user. You can use the query parameter to retrieve also those with pending claims.
         * @summary (Users) Returns your uploaded results
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [executionBefore] Results executed before date (ISO8601)
         * @param {string} [executionAfter] Results executed after date (ISO8601)
         * @param {string} [benchmarkId] UUID benchmark unique identification
         * @param {string} [siteId] UUID site unique identification
         * @param {string} [flavorId] UUID flavor unique identification
         * @param {Array<string>} [tagsIds] UUID tags unique identifications
         * @param {Array<string>} [filters] List of filter conditions (space separated)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,execution_datetime,upload_datetime].&lt;br&gt;Benchmark fields: [benchmark_id,benchmark_name].&lt;br&gt;Site fields: [site_id,site_name,site_address].&lt;br&gt;Flavor fields: [flavor_id,flavor_name].&lt;br&gt;Custom json fields using \&#39;json\&#39; and \&#39;.\&#39; as json field delimiter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserResults(uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, executionBefore?: string, executionAfter?: string, benchmarkId?: string, siteId?: string, flavorId?: string, tagsIds?: Array<string>, filters?: Array<string>, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Results>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserResults(uploadBefore, uploadAfter, perPage, page, executionBefore, executionAfter, benchmarkId, siteId, flavorId, tagsIds, filters, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of users filtered according to your requirements. The response returns a pagination object with the filtered users (if succeeds).
         * @summary (Admins) Filters and list users
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sub] String containing an OIDC subject
         * @param {string} [iss] String containing an OIDC issuer
         * @param {string} [email] Email of user collected by the OIDC token
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Specific fields: [sub,iss,email,registration_datetime]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(perPage?: number, page?: number, sub?: string, iss?: string, email?: string, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(perPage, page, sub, iss, email, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to register yourself into the application. By using this method, you recognize that you have read and understood our terms, conditions and privacy policy at: `https://performance.services.fedcloud.eu/privacy_policy`  The method will return your stored information.
         * @summary (OIDC Token) Registers the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerSelf(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSelf(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to delete the users filtered according to your requirements. To prevent unintentionally delete all users, the method requires of query arguments, otherwise UnprocessableEntity exception is raised.
         * @summary (Admins) Removes one or multiple users
         * @param {string} [sub] String containing an OIDC subject
         * @param {string} [iss] String containing an OIDC issuer
         * @param {string} [email] Email of user collected by the OIDC token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUsers(sub?: string, iss?: string, email?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUsers(sub, iss, email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to get a list of users based on a general search of terms. For example, calling this method with terms=@hotmail&terms=de returns all users with \'hotmail\' and \'de\' on the \'email\'. The response returns a pagination object with the filtered users (if succeeds).
         * @summary (Admins) Filters and list users
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(terms?: Array<string>, sortBy?: string, perPage?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(terms, sortBy, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to check that you have the administration rights. If so, the access returns 204, otherwise 401 or 403 are expected.
         * @summary (Admins) Returns 204 if you are admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tryAdmin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tryAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to update your user data in the database. The method returns by default 204, use a GET method to retrieve the new status of your data.
         * @summary (Users) Updates the logged in user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSelf(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSelf(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Use this method to retrieve your user data stored in the database.
         * @summary (Users) Retrieves the logged in user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelf(options?: any): AxiosPromise<User> {
            return localVarFp.getSelf(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve all the claims uploaded by your user.
         * @summary (Users) Returns your uploaded pending claims
         * @param {'on_review' | 'approved'} [status] Resource current state
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserClaims(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options?: any): AxiosPromise<Claims> {
            return localVarFp.listUserClaims(status, uploadBefore, uploadAfter, perPage, page, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve all the results uploaded by your user. You can use the query parameter to retrieve also those with pending claims.
         * @summary (Users) Returns your uploaded results
         * @param {string} [uploadBefore] Results with upload before date (ISO8601)
         * @param {string} [uploadAfter] Results with upload after date (ISO8601)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [executionBefore] Results executed before date (ISO8601)
         * @param {string} [executionAfter] Results executed after date (ISO8601)
         * @param {string} [benchmarkId] UUID benchmark unique identification
         * @param {string} [siteId] UUID site unique identification
         * @param {string} [flavorId] UUID flavor unique identification
         * @param {Array<string>} [tagsIds] UUID tags unique identifications
         * @param {Array<string>} [filters] List of filter conditions (space separated)
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,execution_datetime,upload_datetime].&lt;br&gt;Benchmark fields: [benchmark_id,benchmark_name].&lt;br&gt;Site fields: [site_id,site_name,site_address].&lt;br&gt;Flavor fields: [flavor_id,flavor_name].&lt;br&gt;Custom json fields using \&#39;json\&#39; and \&#39;.\&#39; as json field delimiter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserResults(uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, executionBefore?: string, executionAfter?: string, benchmarkId?: string, siteId?: string, flavorId?: string, tagsIds?: Array<string>, filters?: Array<string>, sortBy?: string, options?: any): AxiosPromise<Results> {
            return localVarFp.listUserResults(uploadBefore, uploadAfter, perPage, page, executionBefore, executionAfter, benchmarkId, siteId, flavorId, tagsIds, filters, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of users filtered according to your requirements. The response returns a pagination object with the filtered users (if succeeds).
         * @summary (Admins) Filters and list users
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {string} [sub] String containing an OIDC subject
         * @param {string} [iss] String containing an OIDC issuer
         * @param {string} [email] Email of user collected by the OIDC token
         * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Specific fields: [sub,iss,email,registration_datetime]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(perPage?: number, page?: number, sub?: string, iss?: string, email?: string, sortBy?: string, options?: any): AxiosPromise<Users> {
            return localVarFp.listUsers(perPage, page, sub, iss, email, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to register yourself into the application. By using this method, you recognize that you have read and understood our terms, conditions and privacy policy at: `https://performance.services.fedcloud.eu/privacy_policy`  The method will return your stored information.
         * @summary (OIDC Token) Registers the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSelf(options?: any): AxiosPromise<User> {
            return localVarFp.registerSelf(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to delete the users filtered according to your requirements. To prevent unintentionally delete all users, the method requires of query arguments, otherwise UnprocessableEntity exception is raised.
         * @summary (Admins) Removes one or multiple users
         * @param {string} [sub] String containing an OIDC subject
         * @param {string} [iss] String containing an OIDC issuer
         * @param {string} [email] Email of user collected by the OIDC token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUsers(sub?: string, iss?: string, email?: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeUsers(sub, iss, email, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of users based on a general search of terms. For example, calling this method with terms=@hotmail&terms=de returns all users with \'hotmail\' and \'de\' on the \'email\'. The response returns a pagination object with the filtered users (if succeeds).
         * @summary (Admins) Filters and list users
         * @param {Array<string>} [terms] List of terms (string subsets)
         * @param {string} [sortBy] Order to return the results (coma separated)
         * @param {number} [perPage] The number of items to be displayed on a page
         * @param {number} [page] The return page number (1 indexed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(terms?: Array<string>, sortBy?: string, perPage?: number, page?: number, options?: any): AxiosPromise<Users> {
            return localVarFp.searchUsers(terms, sortBy, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to check that you have the administration rights. If so, the access returns 204, otherwise 401 or 403 are expected.
         * @summary (Admins) Returns 204 if you are admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryAdmin(options?: any): AxiosPromise<void> {
            return localVarFp.tryAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to update your user data in the database. The method returns by default 204, use a GET method to retrieve the new status of your data.
         * @summary (Users) Updates the logged in user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSelf(options?: any): AxiosPromise<void> {
            return localVarFp.updateSelf(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Use this method to retrieve your user data stored in the database.
     * @summary (Users) Retrieves the logged in user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getSelf(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getSelf(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve all the claims uploaded by your user.
     * @summary (Users) Returns your uploaded pending claims
     * @param {'on_review' | 'approved'} [status] Resource current state
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,status,upload_datetime]&lt;br&gt;Specific fields: [resource_type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUserClaims(status?: 'on_review' | 'approved', uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, sortBy?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUserClaims(status, uploadBefore, uploadAfter, perPage, page, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve all the results uploaded by your user. You can use the query parameter to retrieve also those with pending claims.
     * @summary (Users) Returns your uploaded results
     * @param {string} [uploadBefore] Results with upload before date (ISO8601)
     * @param {string} [uploadAfter] Results with upload after date (ISO8601)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {string} [executionBefore] Results executed before date (ISO8601)
     * @param {string} [executionAfter] Results executed after date (ISO8601)
     * @param {string} [benchmarkId] UUID benchmark unique identification
     * @param {string} [siteId] UUID site unique identification
     * @param {string} [flavorId] UUID flavor unique identification
     * @param {Array<string>} [tagsIds] UUID tags unique identifications
     * @param {Array<string>} [filters] List of filter conditions (space separated)
     * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Generic fields: [id,execution_datetime,upload_datetime].&lt;br&gt;Benchmark fields: [benchmark_id,benchmark_name].&lt;br&gt;Site fields: [site_id,site_name,site_address].&lt;br&gt;Flavor fields: [flavor_id,flavor_name].&lt;br&gt;Custom json fields using \&#39;json\&#39; and \&#39;.\&#39; as json field delimiter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUserResults(uploadBefore?: string, uploadAfter?: string, perPage?: number, page?: number, executionBefore?: string, executionAfter?: string, benchmarkId?: string, siteId?: string, flavorId?: string, tagsIds?: Array<string>, filters?: Array<string>, sortBy?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUserResults(uploadBefore, uploadAfter, perPage, page, executionBefore, executionAfter, benchmarkId, siteId, flavorId, tagsIds, filters, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of users filtered according to your requirements. The response returns a pagination object with the filtered users (if succeeds).
     * @summary (Admins) Filters and list users
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {string} [sub] String containing an OIDC subject
     * @param {string} [iss] String containing an OIDC issuer
     * @param {string} [email] Email of user collected by the OIDC token
     * @param {string} [sortBy] Order to return the results (coma separated).&lt;br&gt;Specific fields: [sub,iss,email,registration_datetime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(perPage?: number, page?: number, sub?: string, iss?: string, email?: string, sortBy?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers(perPage, page, sub, iss, email, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to register yourself into the application. By using this method, you recognize that you have read and understood our terms, conditions and privacy policy at: `https://performance.services.fedcloud.eu/privacy_policy`  The method will return your stored information.
     * @summary (OIDC Token) Registers the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public registerSelf(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).registerSelf(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to delete the users filtered according to your requirements. To prevent unintentionally delete all users, the method requires of query arguments, otherwise UnprocessableEntity exception is raised.
     * @summary (Admins) Removes one or multiple users
     * @param {string} [sub] String containing an OIDC subject
     * @param {string} [iss] String containing an OIDC issuer
     * @param {string} [email] Email of user collected by the OIDC token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public removeUsers(sub?: string, iss?: string, email?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).removeUsers(sub, iss, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of users based on a general search of terms. For example, calling this method with terms=@hotmail&terms=de returns all users with \'hotmail\' and \'de\' on the \'email\'. The response returns a pagination object with the filtered users (if succeeds).
     * @summary (Admins) Filters and list users
     * @param {Array<string>} [terms] List of terms (string subsets)
     * @param {string} [sortBy] Order to return the results (coma separated)
     * @param {number} [perPage] The number of items to be displayed on a page
     * @param {number} [page] The return page number (1 indexed)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public searchUsers(terms?: Array<string>, sortBy?: string, perPage?: number, page?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).searchUsers(terms, sortBy, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to check that you have the administration rights. If so, the access returns 204, otherwise 401 or 403 are expected.
     * @summary (Admins) Returns 204 if you are admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tryAdmin(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).tryAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to update your user data in the database. The method returns by default 204, use a GET method to retrieve the new status of your data.
     * @summary (Users) Updates the logged in user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateSelf(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateSelf(options).then((request) => request(this.axios, this.basePath));
    }
}


